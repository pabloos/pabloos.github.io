<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>by bit</title>
    <link>https://pabloos.github.io/</link>
    <description>Recent content on by bit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 Jan 2021 21:42:37 +0100</lastBuildDate>
    
	<atom:link href="https://pabloos.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1:1</title>
      <link>https://pabloos.github.io/languages/one2one/</link>
      <pubDate>Sat, 16 Jan 2021 21:42:37 +0100</pubDate>
      
      <guid>https://pabloos.github.io/languages/one2one/</guid>
      <description>The basic idea: a way to get rid of classes There are many well identified classes that only have a one public method, such as iterators, lexers and that kind of walk-on-collections objects:
class Greet { constructor(greet) { this.greet = greet; } greet(name) { console.log(this.greet + &amp;#34; &amp;#34; + name); } } const salut = new Greet(&amp;#34;Hello&amp;#34;); salut.greet(&amp;#34;Pablo&amp;#34;); // Hello Pablo For some cases I use the following instead. That&amp;rsquo;s it, just a functor:</description>
    </item>
    
    <item>
      <title>Use Go interfaces</title>
      <link>https://pabloos.github.io/languages/usegointerfaces/</link>
      <pubDate>Sun, 28 Jun 2020 12:43:10 +0200</pubDate>
      
      <guid>https://pabloos.github.io/languages/usegointerfaces/</guid>
      <description>tl;dr:
   from\to io.Writer io.Reader string []byte bytes.Buffer     io.Writer &amp;ndash; io.Pipe io.WriteString N/A N/A   io.Reader io.Copy &amp;ndash; strings.Builder N/A N/A   string bytes.NewBufferString strings.NewReader &amp;ndash; []byte(&amp;ldquo;io&amp;rdquo;)    []byte bytes.NewBuffer bytes.New{Reader/Buffer} string(byteSlice) &amp;ndash; bytes.NewBuffer   bytes.Buffer it&amp;rsquo;s it&amp;rsquo;s buf.String buf.bytes &amp;ndash;    Go has become a very popular language, so there&amp;rsquo;s day to day multiple posts and tutorials.</description>
    </item>
    
    <item>
      <title>Pipelines</title>
      <link>https://pabloos.github.io/concurrency/pipelines/</link>
      <pubDate>Thu, 09 Apr 2020 13:20:57 +0200</pubDate>
      
      <guid>https://pabloos.github.io/concurrency/pipelines/</guid>
      <description>All the code used here is on my github: pabloos. Keep an eye on it, for clarity I will not reference all the functions. Each section has his own branch.
1. Original Sketch A pipeline is not unlike an assembly line: a queue of jobs that transform an input and sends it to the next stage. In Go an obvious implementation would be based on channels (originally based on an idea in the oficial blog), in which each function represents a separate stage connected with the next one using a channel.</description>
    </item>
    
    <item>
      <title>E2E with Jest And Puppeteer. How I do it.</title>
      <link>https://pabloos.github.io/testing/e2e-with-jest-and-puppeteer.-how-i-do-it/</link>
      <pubDate>Thu, 09 Apr 2020 12:03:21 +0200</pubDate>
      
      <guid>https://pabloos.github.io/testing/e2e-with-jest-and-puppeteer.-how-i-do-it/</guid>
      <description>As a backend developer E2E testing is a must for me. E2E testing does not only check the features of the frontend, it cares about the whole system. A good match for this purpose on Node it&amp;rsquo;s the jest and puppeteer tandem for testing web apps.
(Note: From now on I assume that you have some experience with the API of both technologies)
About the dependencies You will find a bunch of posts about this topic on the internet.</description>
    </item>
    
  </channel>
</rss>